[
    {
        "id": "section-1",
        "title": "1. Resumen general del proyecto",
        "text": "- **Clean Marvel Album** es una aplicación PHP 8.x con arquitectura en capas (Clean Architecture) que:\n  - Gestiona álbumes, héroes y secciones especiales (Secret Room).\n  - Orquesta microservicios dedicados (RAG, OpenAI, Heatmap).\n  - Integra calidad, accesibilidad y pruebas automáticas mediante CI/CD.\n\n- **Tecnologías principales**:\n  - PHP 8.x en la app principal y microservicios (`rag-service`, `openai-service`).\n  - Python + Flask en el `heatmap-service`.\n  - Frontend basado en vistas PHP + HTML + CSS + JS sin framework frontend grande.\n  - SQLite en el microservicio de heatmap; ficheros JSON para knowledge base y embeddings.\n\n- **Arquitectura limpia**:\n  - **Presentación**: controladores HTTP y vistas (`views/*`, `PageController`, `Router`).\n  - **Aplicación**: casos de uso y servicios de orquestación (RAG, generación de contenido, etc.).\n  - **Dominio**: entidades, contratos e interfaces.\n  - **Infraestructura**: repositorios, clientes HTTP, acceso a ficheros, integración con APIs externas.\n\n- **Microservicios actuales**:\n  - `rag-service`: comparación de héroes mediante RAG ligero y agente técnico.\n  - `openai-service`: fachada HTTP a la API de OpenAI para chat/contenido.\n  - `heatmap-service`: tracking y visualización de clics en la web Marvel.\n\n- **Secciones clave de la app**:\n  - `/albums`, `/heroes`: navegación principal de contenido Marvel.\n  - `/comic`: generación de historias/cómics usando OpenAI.\n  - `/seccion` (Secret Room): panel central técnico (Sonar, Sentry, Heatmap, etc.).\n  - `/agentia`: interfaz del **Marvel Agent** (chat técnico, inicialmente simulado).\n\nEn la práctica, Clean Marvel Album actúa como un sandbox técnico y proyecto de máster: combina generación creativa (cómics), paneles de observabilidad y microservicios IA. La elección de Clean Architecture permite que los microservicios cambien o evolucionen sin alterar la lógica de dominio, y facilita probar y desplegar en hosting o cloud con solo ajustar configuración y URLs.\nTambién funciona como un “laboratorio” para prácticas de CI/CD y observabilidad: el monolito orquesta paneles (Sonar, Sentry, GitHub, accesibilidad, performance) y expone proxies seguros que aíslan tokens y dependencias externas.\n\n---"
    },
    {
        "id": "section-2",
        "title": "2. Arquitectura técnica unificada",
        "text": "Mapa mental: la app principal PHP sirve vistas y proxies internos; delega en microservicios IA (`openai-service` y `rag-service`) y en servicios externos (heatmap, accesibilidad, performance). La calidad se asegura con PHPUnit/PHPStan + QA frontend. El despliegue se mueve de local a hosting ajustando únicamente variables de entorno y subdominios, manteniendo el mismo código.\nTodo convive con automatizaciones externas (n8n) que alimentan contenido (último video de Marvel en YouTube) a través de un endpoint PHP seguro, demostrando cómo integrar servicios SaaS sin acoplarlos al dominio."
    },
    {
        "id": "section-3",
        "title": "2.1 App principal (PHP)",
        "text": "- **Routing principal**:\n  - `Src\\Shared\\Http\\Router` y `PageController` mapean rutas como `/`, `/albums`, `/heroes`, `/comic`, `/seccion`, `/agentia`, etc., y cargan vistas en `views/*.php`.\n\n- **Vistas principales** (ejemplos):\n  - `views/albums.php`: listado y gestión de álbumes.\n  - `views/heroes.php`: listado de héroes.\n  - `views/comic.php`: interfaz para generación de cómics.\n  - `views/seccion.php`: **Secret Room**, panel técnico (SonarCloud, Sentry, Heatmap, GitHub PRs, accesibilidad, performance, repo, etc.).\n  - `views/agentia.php`: interfaz del **Marvel Agent**:\n    - Cabecera alineada al estilo de Secret Room.\n    - Panel de chat con mensajes simulados.\n    - Panel lateral con ejemplos de preguntas y explicación del agente.\n\n- **Frontend**:\n  - CSS en `public/assets/css/*`, con estilos reutilizables para tarjetas, botones y grids.\n  - JS específico por página:\n    - `comic.js` (cómic/RAG),\n    - scripts de heatmap, Secret Room, etc.\n    - `agentia.js` (chat simulado, sin backend real).\n\n- **APIs/proxies internos**:\n  - Scripts PHP en `public/api/` (ej. heatmap, accesibilidad, performance, GitHub, Sentry, Sonar, TTS).\n  - Objetivo: ocultar credenciales y normalizar payloads antes de llamar a servicios externos o microservicios.\n\nEn la práctica, la app principal es el “hub” de navegación: renderiza vistas, lanza fetch a los proxies para mantener tokens a salvo y orquesta la UX (cómic, paneles de calidad, Secret Room, Marvel Agent). Esto permite a un desarrollador cambiar servicios sin tocar el frontend, siempre que respete los contratos de los proxies y los microservicios.\nTambién expone proxies para APIs clave: `/api/github-activity.php` (PRs), `/api/sonar-metrics.php` (calidad), `/api/performance-marvel.php` (PageSpeed), `/api/accessibility-marvel.php` (WAVE), `/api/heatmap/*` (tracking), `/api/tts-elevenlabs.php` (TTS) y `/api/marvel-agent.php` (puerta de entrada al agente)."
    },
    {
        "id": "section-4",
        "title": "2.2 Microservicio `rag-service` (RAG de héroes)",
        "text": "- **Responsabilidad**: comparar héroes usando RAG ligero y devolver una respuesta generada por LLM con contexto.\n- **Endpoint**: `POST /rag/heroes`.\n- **Request típico**:\n  ```json\n  {\n    \"heroIds\": [\"ironman\", \"captain-america\"],\n    \"question\": \"¿En qué se parecen y en qué se diferencian?\"\n  }\n  ```\n- **Response típico**:\n  ```json\n  {\n    \"answer\": \"Respuesta generada por el LLM...\",\n    \"contexts\": [\n      { \"heroId\": \"ironman\", \"nombre\": \"Iron Man\", \"contenido\": \"...\", \"score\": 0.92 },\n      { \"heroId\": \"captain-america\", \"nombre\": \"Captain America\", \"contenido\": \"...\", \"score\": 0.89 }\n    ],\n    \"heroIds\": [\"ironman\", \"captain-america\"]\n  }\n  ```\n\n- **Casos de uso / servicios**:\n  - `HeroRagService::compare(array $heroIds, ?string $question)`: valida heroIds/pregunta, recupera contextos, construye prompt narrativo y llama a `openai-service`.\n\n- **Knowledge base**:\n  - `storage/knowledge/heroes.json` (heroId, nombre, contenido).\n  - Embeddings opcionales en `storage/embeddings/heroes.json`.\n\n- **Retrievers**:\n  - Léxico (default): `HeroRetriever` (bolsa de palabras + coseno).\n  - Vectorial (opcional): `VectorHeroRetriever` usa embeddings precalculados y cae al léxico si faltan vectores o config.\n- **RAG profesional (principios aplicados)**:\n  - Separación de conocimiento (JSON/embeddings) y lógica de recuperación.\n  - Cliente LLM desacoplado (`openai-service`) y configurable por `.env`.\n  - Fallback seguro: si faltan embeddings o falla el vectorial, usa el retriever léxico.\n  - Dos flujos en el mismo microservicio:\n    - `/rag/heroes`: comparación de héroes con KB de héroes (`storage/knowledge/heroes.json`, embeddings opcionales en `storage/embeddings/heroes.json`).\n    - `/rag/agent`: RAG técnico de Marvel Agent con KB propia (`storage/marvel_agent_kb.json`, embeddings opcionales en `storage/marvel_agent_embeddings.json`).\n    - Ambos comparten cliente LLM y configuración, con KBs independientes.\n  - Generación de embeddings offline (scripts en `bin/`) y uso opt-in vía flags de entorno para no romper despliegues.\n\n- **Cliente hacia OpenAI**:\n  - `OpenAiHttpClient` llama al microservicio `openai-service` (nunca directo a OpenAI).\n\n- **Configuración relevante** (`rag-service/.env`):\n  - `OPENAI_SERVICE_URL`\n  - `RAG_USE_EMBEDDINGS`\n  - `RAG_EMBEDDINGS_AUTOREFRESH`\n\n- **Tests**: suite propia en `rag-service/tests/` con `phpunit.xml`.\n\nEn la práctica, `rag-service` opera como doble RAG: uno para comparar héroes y otro (Marvel Agent) para responder preguntas técnicas sobre el propio proyecto. Ambos reutilizan el mismo cliente LLM y se configuran vía `.env`, lo que facilita moverlos entre local y hosting. El flujo típico: el frontend llama a `/rag/heroes` o `/rag/agent`, el servicio recupera contexto (KB de héroes o KB del agente), construye prompt, delega en `openai-service` y devuelve `answer + contexts`."
    },
    {
        "id": "section-5",
        "title": "2.3 Microservicio `openai-service` (fachada OpenAI)",
        "text": "- **Responsabilidad**: ofrecer un endpoint HTTP controlado hacia OpenAI.\n- **Endpoint**: `POST /v1/chat`.\n- **Request típico**:\n  ```json\n  {\n    \"messages\": [\n      { \"role\": \"system\", \"content\": \"Instrucciones...\" },\n      { \"role\": \"user\", \"content\": \"Pregunta del usuario...\" }\n    ]\n  }\n  ```\n- **Response típico**:\n  ```json\n  { \"ok\": true, \"content\": \"Texto generado por el modelo\" }\n  ```\n  o `{ \"ok\": false, \"error\": \"Mensaje de error\" }`.\n\n- **Flujo interno**:\n  - `public/index.php` → `Http\\Router` → `OpenAIController` → `Application\\UseCase\\GenerateContent` → `Infrastructure\\Client\\OpenAiClient` (Guzzle).\n  - `GenerateContent` limpia fences de código y genera fallback JSON en caso de fallo.\n\n- **Configuración** (`openai-service/.env`):\n  - `OPENAI_API_KEY` (obligatorio),\n  - `OPENAI_API_BASE` (default `https://api.openai.com/v1`),\n  - `OPENAI_MODEL` (default `gpt-4o-mini`),\n  - `ALLOWED_ORIGINS` para CORS.\n\n- **Tests**: suite propia en `openai-service/tests/` con `phpunit.xml`.\n\nEn la práctica, `openai-service` es una capa de seguridad y desac acoplamiento: centraliza la API key y el modelo, aplica CORS y valida payloads antes de hablar con OpenAI. Esto permite cambiar de modelo o endpoint sin tocar el resto del sistema y registrar fallos de forma controlada."
    },
    {
        "id": "section-6",
        "title": "2.4 Microservicio `heatmap-service` (clics y analítica)",
        "text": "- **Responsabilidad**: registrar clics y exponer eventos/visualización de heatmap.\n- **Tecnología**: Python + Flask + SQLite, dockerizado (VM).\n- **Endpoints externos**: `GET /`, `GET /health`, `POST /track` (X-API-Token), `GET /events` (filtros).\n- **Integración PHP**: proxies en `public/api/heatmap/*.php` inyectan `HEATMAP_API_TOKEN` y usan `HEATMAP_API_BASE_URL`. Panel en `/secret-heatmap`.\n\nEn la práctica, el heatmap registra clics desde todas las vistas y los muestra en un panel técnico. Al estar dockerizado en una VM, se puede refrescar la imagen o mover la instancia sin tocar el backend PHP, siempre que se actualice `HEATMAP_API_BASE_URL` y el token."
    },
    {
        "id": "section-7",
        "title": "2.5 Flujos clave",
        "text": "- **Generación de cómic**: frontend en `/comic` → `POST /comics/generate` (app principal) → `openai-service /v1/chat` → respuesta en vista.\n- **Comparación RAG**: frontend → `POST /rag/heroes` → retriever léxico/vectorial → `openai-service /v1/chat` → respuesta + contextos.\n- **Marvel Agent (/agentia)**: solo frontend; chat simulado con JS placeholder. El botón en Secret Room apunta a `/agentia`.\n\nUn flujo típico de cómic: el usuario en `/comic` envía héroes + prompt → la app llama a `/comics/generate` → `openai-service` responde → se renderiza el texto y opcionalmente se narra con TTS. Para RAG de héroes, el frontend envía `heroIds` a `/rag/heroes`, recibe `answer + contexts` y los muestra con audio si está habilitado. Para Marvel Agent, el frontend envía `question` a `/rag/agent` (vía proxy `/api/marvel-agent.php`) y recibe una respuesta técnica basada en la memoria maestra.\nAutomatización n8n: un workflow (`n8n/Daily Marvel YouTube Video Fetcher and Backend Sync.json`) ejecuta un trigger horario, consulta el último video de Marvel en YouTube (`https://www.googleapis.com/youtube/v3/search` con `GOOGLE_YT_API_KEY`) y lo envía al backend PHP (`/api/actualizar-video-marvel.php`) con Authorization Bearer `MARVEL_UPDATE_TOKEN`. Así se refresca contenido sin tocar el core."
    },
    {
        "id": "section-8",
        "title": "2.6 Infraestructura, despliegue y hosting de microservicios",
        "text": "Clean Marvel Album está pensado para moverse entre local y producción sin cambiar código: basta con ajustar URLs de servicio y flags en `.env`. Así, el mismo código sirve tanto en localhost como en hosting, y los microservicios pueden vivir en subdominios o en una VM dockerizada.\n\n- **Mapa de despliegue (local)**:\n  - App principal (PHP): `localhost:8080` (también `docker-compose.yml` expone 8080). El dev levanta `php -S ...` o el contenedor de compose.\n  - `openai-service` (PHP): `localhost:8081`, endpoint `POST /v1/chat`.\n  - `rag-service` (PHP): `localhost:8082`, endpoints `POST /rag/heroes` y `POST /rag/agent`.\n  - `heatmap-service` (Python/Flask): según docs, expuesto en `http://34.74.102.123:8080` (VM). Endpoints `/`, `/health`, `POST /track`, `GET /events`. En local se podría apuntar a esa IP o levantar uno propio con Docker.\n- **Mapa de despliegue (hosting/producción)**:\n  - App principal: dominio principal indicado en `.env` (`APP_PUBLIC_URL`), hosting PHP.\n  - `openai-service`: subdominio documentado en bootstrap como fallback hosting: `https://openai-service.contenido.creawebes.com/v1/chat` si no hay `OPENAI_SERVICE_URL`.\n  - `rag-service`: subdominio para hosting: `https://rag-service.contenido.creawebes.com` (bootstrap detecta host) con rutas `/rag/heroes` y `/rag/agent`.\n  - `heatmap-service`: dockerizado en VM (Google Cloud, según docs) accesible en `http://34.74.102.123:8080`.\n- **Docker e imágenes**:\n  - `docker-compose.yml` (raíz): levanta la app principal PHP con servidor embebido en 8080 para desarrollo rápido.\n  - `heatmap-service`: tiene Dockerfile; se construye como imagen `heatmap-service` y se ejecuta en contenedor (`docker run -p 8080:8080 ...`). Volumen montado para `heatmap.db`.\n  - No hay Dockerfiles visibles para `rag-service` u `openai-service` en el repo; se sirven con `php -S` en local/hosting. Se configuran por `.env` y subdominios.\n- **Subdominios y hosting**:\n  - Los microservicios PHP resuelven su URL vía `.env` (`OPENAI_SERVICE_URL`, `RAG_SERVICE_URL`), con fallback a subdominios `openai-service.contenido.creawebes.com` y `rag-service.contenido.creawebes.com` cuando están en hosting.\n  - La app principal consume microservicios vía HTTP; proxies PHP (`public/api/*.php`) ocultan tokens y orquestan llamadas externas (heatmap, etc.).\n- **Automatización externa (n8n)**:\n  - Workflow programado que consulta la API de YouTube y envía el último video Marvel al endpoint PHP `/api/actualizar-video-marvel.php` con Authorization Bearer (`MARVEL_UPDATE_TOKEN`). Usa `GOOGLE_YT_API_KEY` y se ejecuta de forma recurrente.\n- **Entornos (resumen)**:\n  - Local: App 8080 / `openai-service` 8081 / `rag-service` 8082 / heatmap (VM 34.74.102.123:8080 o localhost si se levanta).\n  - Producción: App en hosting PHP (`APP_PUBLIC_URL`), `openai-service` y `rag-service` en subdominios configurados por `.env`/bootstrap, heatmap en VM Docker (IP/URL documentada).\n- **RAG-service compartido**:\n  - Un único `rag-service` expone dos endpoints:\n    - `/rag/heroes` para comparación de héroes con KB de héroes.\n    - `/rag/agent` para preguntas técnicas usando la memoria maestra (`storage/marvel_agent_kb.json`).\n  - Ambos flujos reutilizan el mismo cliente hacia `openai-service` y se benefician de embeddings opcionales, con fallback léxico.\n\n---"
    },
    {
        "id": "section-9",
        "title": "3. Calidad, CI y auditorías",
        "text": "- **Pruebas**:\n  - App principal: `phpunit.xml.dist`.\n  - Microservicios: `rag-service/phpunit.xml`, `openai-service/phpunit.xml`.\n  - Comandos típicos:\n    - `vendor/bin/phpunit`\n    - `cd rag-service && ../vendor/bin/phpunit`\n    - `cd openai-service && ../vendor/bin/phpunit`\n\n- **PHPStan**: `vendor/bin/phpstan analyse --memory-limit=512M` (config en `phpstan.neon`, excluye `src/Dev`).\n\n- **QA frontend**: Playwright (`playwright.config.cjs`), Pa11y (`pa11y-all.sh`), Lighthouse (`lighthouserc.json`), SonarCloud (ver ADR-003).\n\n- **CI/CD (GitHub Actions)**: jobs de PHPUnit, PHPStan, Pa11y, Lighthouse, Playwright, SonarCloud; deploy/rollback FTP según pipelines definidos.\n\n---\n\nEn conjunto, PHPUnit + PHPStan cubren la solidez del backend; Playwright, Pa11y y Lighthouse vigilan la UX, accesibilidad y rendimiento; SonarCloud da visibilidad continua de calidad. Este “cinturón de seguridad” automatizado evita regresiones y mantiene el código en niveles profesionales antes de cualquier despliegue."
    },
    {
        "id": "section-10",
        "title": "4. Documentación y fuentes de conocimiento",
        "text": "- **Índice general**: `docs/README.md`.\n- **Arquitectura**: `docs/ARCHITECTURE.md`; ADRs en `docs/architecture/ADR-*.md`.\n- **APIs**: `docs/API_REFERENCE.md` (usa endpoints reales: `/comics/generate`, `/rag/heroes`, `/v1/chat`, proxies heatmap).\n- **Microservicios**:\n  - `rag-service/README.md`, `rag-service/doc/*`.\n  - `openai-service/doc/*`.\n  - `docs/microservicioheatmap/README.md`.\n- **Guías y otros**: `docs/guides/getting-started.md`, `docs/guides/testing.md`, `docs/guides/authentication.md`, `docs/USE_CASES.md`, `docs/ROADMAP.md`, `docs/TASKS_AUTOMATION.md`.\n\n---\n\nUn desarrollador nuevo debería empezar por `docs/README.md` para el índice, leer `docs/ARCHITECTURE.md` y los ADRs para decisiones clave, luego revisar `API_REFERENCE.md` y los README de cada microservicio. Las guías de testing y automatización explican cómo ejecutar suites y scripts, acelerando la curva de aprendizaje."
    },
    {
        "id": "section-11",
        "title": "5. Reglas para el futuro Marvel Agent",
        "text": "1. **Fuentes permitidas**: este archivo, la documentación listada y el código real. Si hay conflicto, prevalece el código.\n2. **No inventar**: no crear endpoints ni microservicios inexistentes. Si falta información, indicarlo.\n3. **Citar**: mencionar el archivo de soporte cuando aplique (ej.: `docs/ARCHITECTURE.md`, `rag-service/README.md`).\n4. **Endpoints reales**: `/v1/chat` (openai-service), `/rag/heroes` (rag-service), proxies heatmap (`/api/heatmap/*.php`), rutas HTML según `PageController`.\n5. **Configuración**: hablar solo de variables que estén en `.env` o en código (`OPENAI_API_KEY`, `OPENAI_SERVICE_URL`, `RAG_USE_EMBEDDINGS`, `HEATMAP_API_*`, etc.).\n6. **Estado del agente**: `/agentia` es frontend con respuestas simuladas; el backend RAG/LLM se añadirá después usando esta memoria.\n7. **Infra y despliegue**: el agente puede responder dónde corren microservicios (subdominios, hosting, VM/Google Cloud) y qué está dockerizado, solo si está documentado aquí, en los docs listados o en configuración real. Si falta info, debe decir que no está documentado.\n8. **Respuestas explicativas**: debe priorizar respuestas técnicas y explicativas (no solo bullets), usando la info de infraestructura y microservicios para ubicar dónde corre cada componente.\n\n---"
    },
    {
        "id": "section-12",
        "title": "6. Ejemplos de respuestas del Marvel Agent",
        "text": "- **Pregunta:** “¿Tiene arquitectura clean?”  \n  **Respuesta ejemplo:** Sí. La app principal sigue Clean Architecture: Presentación (router/vistas) → Aplicación (casos de uso) → Dominio (entidades/contratos) → Infraestructura (repos, clientes externos). Las dependencias fluyen hacia el dominio, lo que permite cambiar microservicios o proveedores sin romper la lógica central.\n\n- **Pregunta:** “¿Dónde están desplegados los microservicios?”  \n  **Respuesta ejemplo:** En local: app en `localhost:8080`, `openai-service` en `8081`, `rag-service` en `8082`. En hosting: la app vive en el dominio principal (`APP_PUBLIC_URL`) y los microservicios PHP se exponen en subdominios (`openai-service.contenido.creawebes.com`, `rag-service.contenido.creawebes.com`). El heatmap está dockerizado en una VM accesible en `http://34.74.102.123:8080`.\n\n- **Pregunta:** “¿Qué hace el microservicio de heatmap?”  \n  **Respuesta ejemplo:** Es un servicio Python/Flask con SQLite que registra clics de la web. Exponen `/`, `/health`, `POST /track` y `GET /events`. Está dockerizado en una VM (Google Cloud) y se consume desde la app PHP mediante proxies que inyectan el token `HEATMAP_API_TOKEN`.\n\n- **Pregunta:** “¿Cuál es la diferencia entre /rag/heroes y /rag/agent?”  \n  **Respuesta ejemplo:** Ambos viven en el mismo `rag-service`. `/rag/heroes` compara dos héroes usando la KB de héroes (JSON + embeddings opcionales). `/rag/agent` responde preguntas técnicas usando la memoria maestra del proyecto (otra KB). Comparten cliente LLM (`openai-service`) y configuración, con fallback léxico si no hay embeddings.\n\n- **Pregunta:** “¿Qué automatizaciones externas usa el proyecto?”  \n  **Respuesta ejemplo:** Hay un workflow n8n (`Daily Marvel YouTube Video Fetcher and Backend Sync.json`) que consulta la API de YouTube con `GOOGLE_YT_API_KEY` y envía el último video al endpoint PHP `/api/actualizar-video-marvel.php` con autorización Bearer (`MARVEL_UPDATE_TOKEN`). Así se refrescan contenidos sin tocar el dominio.\n\n---\n\n> Cuando se actualice esta memoria, es necesario regenerar la KB ejecutando:  \n> `cd rag-service && php bin/build_marvel_agent_kb.php`"
    }
]