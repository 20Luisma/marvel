[
    {
        "id": "section-1",
        "title": "1. Resumen general del proyecto",
        "text": "- **Clean Marvel Album** es una aplicación PHP 8.x con arquitectura en capas (Clean Architecture) que:\n  - Gestiona álbumes, héroes y secciones especiales (Secret Room).\n  - Orquesta microservicios dedicados (RAG, OpenAI, Heatmap).\n  - Integra calidad, accesibilidad y pruebas automáticas mediante CI/CD.\n\n- **Tecnologías principales**:\n  - PHP 8.x en la app principal y microservicios (`rag-service`, `openai-service`).\n  - Python + Flask en el `heatmap-service`.\n  - Frontend basado en vistas PHP + HTML + CSS + JS sin framework frontend grande.\n  - SQLite en el microservicio de heatmap; ficheros JSON para knowledge base y embeddings.\n\n- **Arquitectura limpia**:\n  - **Presentación**: controladores HTTP y vistas (`views/*`, `PageController`, `Router`).\n  - **Aplicación**: casos de uso y servicios de orquestación (RAG, generación de contenido, etc.).\n  - **Dominio**: entidades, contratos e interfaces.\n  - **Infraestructura**: repositorios, clientes HTTP, acceso a ficheros, integración con APIs externas.\n\n- **Microservicios actuales**:\n  - `rag-service`: comparación de héroes mediante RAG ligero y agente técnico.\n  - `openai-service`: fachada HTTP a la API de OpenAI para chat/contenido.\n  - `heatmap-service`: tracking y visualización de clics en la web Marvel.\n\n- **Secciones clave de la app**:\n  - `/albums`, `/heroes`: navegación principal de contenido Marvel.\n  - `/comic`: generación de historias/cómics usando OpenAI.\n  - `/seccion` (Secret Room): panel central técnico (Sonar, Sentry, Heatmap, etc.).\n  - `/agentia`: interfaz del **Marvel Agent** (chat técnico conectado al microservicio RAG).\n  - `/presentation`: presentación interactiva del TFM con métricas en tiempo real.\n\n- **Entornos y Despliegue**:\n  - **Local**: para desarrollo y pruebas rápidas.\n  - **Staging**: entorno de pruebas pre-producción (`staging` subdominio) sincronizado automáticamente con `main`.\n  - **Producción**: entorno final estable optimizado para el usuario.\n  - **Estrategia de Mirroring (entorno espejo)**: garantiza que staging y producción compartan la misma estructura y lógica, validando cambios antes del despliegue final.\n\nEn la práctica, Clean Marvel Album actúa como un sandbox técnico y proyecto de máster: combina generación creativa (cómics), paneles de observabilidad y microservicios IA. La elección de Clean Architecture permite que los microservicios cambien o evolucionen sin alterar la lógica de dominio, y facilita probar y desplegar en hosting o cloud con solo ajustar configuración y URLs.\nTambién funciona como un “laboratorio” para prácticas de CI/CD y observabilidad: el monolito orquesta paneles (Sonar, Sentry, GitHub, accesibilidad, performance) y expone proxies seguros que aíslan tokens y dependencias externas. Desde la v1.3.0, cuenta con un flujo de **Semantic Release** que automatiza el versionado y el despliegue profesional.\n\n\n---"
    },
    {
        "id": "section-2",
        "title": "2. Arquitectura técnica unificada",
        "text": "Mapa mental: la app principal PHP sirve vistas y proxies internos; delega en microservicios IA (`openai-service` y `rag-service`) y en servicios externos (heatmap, accesibilidad, performance). La calidad se asegura con PHPUnit/PHPStan + QA frontend. El despliegue se mueve de local a hosting ajustando únicamente variables de entorno y subdominios, manteniendo el mismo código.\nTodo convive con automatizaciones externas (n8n) que alimentan contenido (último video de Marvel en YouTube) a través de un endpoint PHP seguro, demostrando cómo integrar servicios SaaS sin acoplarlos al dominio."
    },
    {
        "id": "section-3",
        "title": "2.1 App principal (PHP)",
        "text": "- **Routing principal**:\n  - `App\\Shared\\Http\\Router` y `PageController` mapean rutas como `/`, `/albums`, `/heroes`, `/comic`, `/seccion`, `/agentia`, etc., y cargan vistas en `views/*.php`.\n\n- **Vistas principales** (ejemplos):\n  - `views/albums.php`: listado y gestión de álbumes.\n  - `views/heroes.php`: listado de héroes.\n  - `views/comic.php`: interfaz para generación de cómics.\n  - `views/seccion.php`: **Secret Room**, panel técnico (SonarCloud, Sentry, Heatmap, GitHub PRs, accesibilidad, performance, repo, etc.).\n  - `views/agentia.php`: interfaz del **Marvel Agent**:\n    - Cabecera alineada al estilo de Secret Room.\n    - Panel de chat con mensajes simulados.\n    - Panel lateral con ejemplos de preguntas y explicación del agente.\n\n- **Frontend**:\n  - CSS en `public/assets/css/*`, con estilos reutilizables para tarjetas, botones y grids.\n  - JS específico por página:\n    - `comic.js` (cómic/RAG),\n    - scripts de heatmap, Secret Room, etc.\n    - `agentia.js` (chat simulado, sin backend real).\n\n- **APIs/proxies internos**:\n  - Scripts PHP en `public/api/` (ej. heatmap, accesibilidad, performance, GitHub, Sentry, Sonar, TTS).\n  - Objetivo: ocultar credenciales y normalizar payloads antes de llamar a servicios externos o microservicios.\n\nEn la práctica, la app principal es el “hub” de navegación: renderiza vistas, lanza fetch a los proxies para mantener tokens a salvo y orquesta la UX (cómic, paneles de calidad, Secret Room, Marvel Agent). Esto permite a un desarrollador cambiar servicios sin tocar el frontend, siempre que respete los contratos de los proxies y los microservicios.\nTambién expone proxies para APIs clave: `/api/github-activity.php` (PRs), `/api/sonar-metrics.php` (calidad), `/api/performance-marvel.php` (PageSpeed), `/api/accessibility-marvel.php` (WAVE), `/api/heatmap/*` (tracking), `/api/tts-elevenlabs.php` (TTS) y `/api/marvel-agent.php` (puerta de entrada al agente)."
    },
    {
        "id": "section-4",
        "title": "2.2 Microservicio `rag-service` (RAG de héroes)",
        "text": "- **Responsabilidad**: comparar héroes usando RAG ligero y devolver una respuesta generada por LLM con contexto.\n- **Endpoint**: `POST /rag/heroes`.\n- **Request típico**:\n  ```json\n  {\n    \"heroIds\": [\"ironman\", \"captain-america\"],\n    \"question\": \"¿En qué se parecen y en qué se diferencian?\"\n  }\n  ```\n- **Response típico**:\n  ```json\n  {\n    \"answer\": \"Respuesta generada por el LLM...\",\n    \"contexts\": [\n      { \"heroId\": \"ironman\", \"nombre\": \"Iron Man\", \"contenido\": \"...\", \"score\": 0.92 },\n      { \"heroId\": \"captain-america\", \"nombre\": \"Captain America\", \"contenido\": \"...\", \"score\": 0.89 }\n    ],\n    \"heroIds\": [\"ironman\", \"captain-america\"]\n  }\n  ```\n\n- **Casos de uso / servicios**:\n  - `HeroRagService::compare(array $heroIds, ?string $question)`: valida heroIds/pregunta, recupera contextos, construye prompt narrativo y llama a `openai-service`.\n\n- **Knowledge base**:\n  - `storage/knowledge/heroes.json` (heroId, nombre, contenido).\n  - Embeddings opcionales en `storage/embeddings/heroes.json`.\n\n- **Retrievers**:\n  - Léxico (default): `HeroRetriever` (bolsa de palabras + coseno).\n  - Vectorial (opcional): `VectorHeroRetriever` usa embeddings precalculados y cae al léxico si faltan vectores o config.\n- **RAG (principios aplicados)**:\n  - Separación de conocimiento (JSON/embeddings) y lógica de recuperación.\n  - Cliente LLM desacoplado (`openai-service`) y configurable por `.env`.\n  - Fallback seguro: si faltan embeddings o falla el vectorial, usa el retriever léxico.\n  - Dos flujos en el mismo microservicio:\n    - `/rag/heroes`: comparación de héroes con KB de héroes (`storage/knowledge/heroes.json`, embeddings opcionales en `storage/embeddings/heroes.json`).\n    - `/rag/agent`: RAG técnico de Marvel Agent con KB propia (`storage/marvel_agent_kb.json`, embeddings opcionales en `storage/marvel_agent_embeddings.json`).\n    - Ambos comparten cliente LLM y configuración, con KBs independientes.\n    - Estado actual: el flujo de héroes opera en modo léxico (no hay `storage/embeddings/heroes.json` generado). El flujo del Marvel Agent es un RAG completo: embeddings generados (`storage/marvel_agent_embeddings.json`), `RAG_USE_EMBEDDINGS=1` activo y recuperación vectorial por defecto, con fallback léxico solo si faltaran vectores.\n    - Para activar vectorial en héroes: generar `storage/embeddings/heroes.json` con embeddings y mantener `RAG_USE_EMBEDDINGS=1`; hasta entonces, la comparación de héroes se resuelve con el retriever léxico.\n  - Generación de embeddings offline (scripts en `bin/`) y uso opt-in vía flags de entorno para no romper despliegues.\n\n- **Cliente hacia OpenAI**:\n  - `OpenAiHttpClient` llama al microservicio `openai-service` (nunca directo a OpenAI).\n\n- **Configuración relevante** (`rag-service/.env`):\n  - `OPENAI_SERVICE_URL`\n  - `RAG_USE_EMBEDDINGS`\n  - `RAG_EMBEDDINGS_AUTOREFRESH`\n- **Estado actual (local)**:\n  - Embeddings del Marvel Agent generados en `rag-service/storage/marvel_agent_embeddings.json`.\n  - `RAG_USE_EMBEDDINGS=1`, modo vectorial activo por defecto; si faltan vectores, cae al retriever léxico.\n\n- **Tests**: suite propia en `rag-service/tests/` con `phpunit.xml`.\n\n**Mantenimiento rápido:** cada vez que agregues memoria en el markdown maestro, regenera KB y embeddings exportando `OPENAI_API_KEY` en la consola y ejecutando: `cd rag-service && ./bin/refresh_marvel_agent.sh`.\n\nEn la práctica, `rag-service` opera como doble RAG: uno para comparar héroes y otro (Marvel Agent) para responder preguntas técnicas sobre el propio proyecto. Ambos reutilizan el mismo cliente LLM y se configuran vía `.env`, lo que facilita moverlos entre local y hosting. El flujo típico: el frontend llama a `/rag/heroes` o `/rag/agent`, el servicio recupera contexto (KB de héroes o KB del agente), construye prompt, delega en `openai-service` y devuelve `answer + contexts`."
    },
    {
        "id": "section-5",
        "title": "2.3 Microservicio `openai-service` (fachada OpenAI)",
        "text": "- **Responsabilidad**: ofrecer un endpoint HTTP controlado hacia OpenAI.\n- **Endpoint**: `POST /v1/chat`.\n- **Request típico**:\n  ```json\n  {\n    \"messages\": [\n      { \"role\": \"system\", \"content\": \"Instrucciones...\" },\n      { \"role\": \"user\", \"content\": \"Pregunta del usuario...\" }\n    ]\n  }\n  ```\n- **Response típico**:\n  ```json\n  { \"ok\": true, \"content\": \"Texto generado por el modelo\" }\n  ```\n  o `{ \"ok\": false, \"error\": \"Mensaje de error\" }`.\n\n- **Flujo interno**:\n  - `public/index.php` → `Http\\Router` → `OpenAIController` → `Application\\UseCase\\GenerateContent` → `Infrastructure\\Client\\OpenAiClient` (Guzzle).\n  - `GenerateContent` limpia fences de código y genera fallback JSON en caso de fallo.\n\n- **Configuración** (`openai-service/.env`):\n  - `OPENAI_API_KEY` (obligatorio),\n  - `OPENAI_API_BASE` (default `https://api.openai.com/v1`),\n  - `OPENAI_MODEL` (default `gpt-4o-mini`),\n  - `ALLOWED_ORIGINS` para CORS.\n\n- **Tests**: suite propia en `openai-service/tests/` con `phpunit.xml`.\n\nEn la práctica, `openai-service` es una capa de seguridad y desac acoplamiento: centraliza la API key y el modelo, aplica CORS y valida payloads antes de hablar con OpenAI. Esto permite cambiar de modelo o endpoint sin tocar el resto del sistema y registrar fallos de forma controlada."
    },
    {
        "id": "section-6",
        "title": "2.4 Microservicio `heatmap-service` (clics y analítica)",
        "text": "- **Responsabilidad**: registrar clics y exponer eventos/visualización de heatmap.\n- **Tecnología**: Python + Flask + SQLite, dockerizado (VM).\n- **Endpoints externos**: `GET /`, `GET /health`, `POST /track` (X-API-Token), `GET /events` (filtros).\n- **Integración PHP**: proxies en `public/api/heatmap/*.php` inyectan `HEATMAP_API_TOKEN` y usan `HEATMAP_API_BASE_URL`. Panel en `/secret-heatmap`.\n\nEn la práctica, el heatmap registra clics desde todas las vistas y los muestra en un panel técnico. Al estar dockerizado en una VM, se puede refrescar la imagen o mover la instancia sin tocar el backend PHP, siempre que se actualice `HEATMAP_API_BASE_URL` y el token."
    },
    {
        "id": "section-7",
        "title": "2.5 Flujos clave",
        "text": "- **Generación de cómic**: frontend en `/comic` → `POST /comics/generate` (app principal) → `openai-service /v1/chat` → respuesta en vista.\n- **Comparación RAG**: frontend → `POST /rag/heroes` → retriever léxico/vectorial → `openai-service /v1/chat` → respuesta + contextos.\n- **Marvel Agent (/agentia)**: solo frontend; chat simulado con JS placeholder. El botón en Secret Room apunta a `/agentia`.\n\nUn flujo típico de cómic: el usuario en `/comic` envía héroes + prompt → la app llama a `/comics/generate` → `openai-service` responde → se renderiza el texto y opcionalmente se narra con TTS. Para RAG de héroes, el frontend envía `heroIds` a `/rag/heroes`, recibe `answer + contexts` y los muestra con audio si está habilitado. Para Marvel Agent, el frontend envía `question` a `/rag/agent` (vía proxy `/api/marvel-agent.php`) y recibe una respuesta técnica basada en la memoria maestra.\nAutomatización n8n: un workflow (`n8n/Daily Marvel YouTube Video Fetcher and Backend Sync.json`) ejecuta un trigger horario, consulta el último video de Marvel en YouTube (`https://www.googleapis.com/youtube/v3/search` con `GOOGLE_YT_API_KEY`) y lo envía al backend PHP (`/api/actualizar-video-marvel.php`) con Authorization Bearer `MARVEL_UPDATE_TOKEN`. Así se refresca contenido sin tocar el core."
    },
    {
        "id": "section-8",
        "title": "2.6 Infraestructura, despliegue y hosting de microservicios",
        "text": "Clean Marvel Album está pensado para moverse entre local y producción sin cambiar código: basta con ajustar URLs de servicio y flags en `.env`. Así, el mismo código sirve tanto en localhost como en hosting, puede orquestarse en Kubernetes y los microservicios pueden vivir en subdominios o en una VM dockerizada.\n\n- **Mapa de despliegue (local)**:\n  - App principal (PHP): `localhost:8080` (también `docker-compose.yml` expone 8080). El dev levanta `php -S ...` o el contenedor de compose.\n  - `openai-service` (PHP): `localhost:8081`, endpoint `POST /v1/chat`.\n  - `rag-service` (PHP): `localhost:8082`, endpoints `POST /rag/heroes` y `POST /rag/agent`.\n  - `heatmap-service` (Python/Flask): según docs, expuesto en `http://34.74.102.123:8080` (VM). Endpoints `/`, `/health`, `POST /track`, `GET /events`. En local se podría apuntar a esa IP o levantar uno propio con Docker.\n- **Mapa de despliegue (hosting/producción)**:\n  - App principal: dominio principal indicado en `.env` (`APP_PUBLIC_URL`), hosting PHP.\n  - `openai-service`: subdominio documentado en bootstrap como fallback hosting: `https://openai-service.contenido.creawebes.com/v1/chat` si no hay `OPENAI_SERVICE_URL`.\n  - `rag-service`: subdominio para hosting: `https://rag-service.contenido.creawebes.com` (bootstrap detecta host) con rutas `/rag/heroes` y `/rag/agent`.\n  - `heatmap-service`: dockerizado en VM (Google Cloud, según docs) accesible en `http://34.74.102.123:8080`.\n- **Docker e imágenes**:\n  - `docker-compose.yml` (raíz): levanta la app principal PHP con servidor embebido en 8080 para desarrollo rápido.\n  - App principal: no hay `Dockerfile` en la raíz del repositorio. En `k8s/DEPLOY_K8S.md` hay un Dockerfile de referencia para construir una imagen (no versionado).\n  - `openai-service` y `rag-service`: incluyen `Dockerfile` en cada carpeta. Las imágenes referenciadas en manifiestos son ejemplos y deben ajustarse al registry del entorno.\n  - `heatmap-service`: microservicio externo (fuera de este repositorio); su Dockerfile se documenta en `docs/microservicioheatmap/README.md`.\n- **Kubernetes (nuevo)**:\n  - Manifiestos en `k8s/*.yaml` definen Deployments (2 réplicas) + Services `ClusterIP` para `clean-marvel`, `rag-service`, `openai-service` y un Ingress NGINX con host `clean-marvel.local`.\n  - Ingress: `/` apunta a la app principal; `/api/rag/*` se reescribe a `/rag/$2` hacia `rag-service`; `/api/openai/*` se reescribe a `/$2` hacia `openai-service` (puerto 8081).\n  - ConfigMaps: `clean-marvel-config`, `rag-service-config`, `openai-service-config` (URLs internas, flags como `RAG_USE_EMBEDDINGS=0`, CORS y voz ElevenLabs). Secrets `clean-marvel-secrets` agrupa `INTERNAL_API_KEY`, `OPENAI_API_KEY`, `ELEVENLABS_API_KEY` y tokens externos con placeholders `CHANGEME`.\n  - Pipeline: flujo sugerido (documentación). No implica que exista un pipeline de build/push configurado para Kubernetes en este repositorio.\n  - Debug: `kubectl port-forward svc/clean-marvel 8080:80`, `svc/rag-service 8082:80`, `svc/openai-service 8081:8081`. Host Ingress `clean-marvel.local` es placeholder; ajustar DNS/TLS reales.\n- **Subdominios y hosting**:\n  - Los microservicios PHP resuelven su URL vía `.env` (`OPENAI_SERVICE_URL`, `RAG_SERVICE_URL`), con fallback a subdominios `openai-service.contenido.creawebes.com` y `rag-service.contenido.creawebes.com` cuando están en hosting.\n  - La app principal consume microservicios vía HTTP; proxies PHP (`public/api/*.php`) ocultan tokens y orquestan llamadas externas (heatmap, etc.).\n- **Automatización externa (n8n)**:\n  - Workflow programado que consulta la API de YouTube y envía el último video Marvel al endpoint PHP `/api/actualizar-video-marvel.php` con Authorization Bearer (`MARVEL_UPDATE_TOKEN`). Usa `GOOGLE_YT_API_KEY` y se ejecuta de forma recurrente.\n- **Entornos (resumen)**:\n  - Local: App 8080 / `openai-service` 8081 / `rag-service` 8082 / heatmap (VM 34.74.102.123:8080 o localhost si se levanta).\n  - Producción: App en hosting PHP (`APP_PUBLIC_URL`), `openai-service` y `rag-service` en subdominios configurados por `.env`/bootstrap, heatmap en VM Docker (IP/URL documentada).\n- **RAG-service compartido**:\n  - Un único `rag-service` expone dos endpoints:\n    - `/rag/heroes` para comparación de héroes con KB de héroes.\n    - `/rag/agent` para preguntas técnicas usando la memoria maestra (`storage/marvel_agent_kb.json`).\n  - Ambos flujos reutilizan el mismo cliente hacia `openai-service` y se benefician de embeddings opcionales, con fallback léxico.\n\n- **Integridad del Dominio (DDD)**:\n  - Se han implementado **Value Objects** (`HeroId`, `AlbumId`) para garantizar la integridad de los datos en toda la aplicación.\n  - El sistema utiliza tipado estricto y validaciones de dominio para evitar estados inconsistentes.\n\n- **Flujo de Ingeniería Profesional**:\n  - **Versionado Semántico**: Uso de `standard-version` para gestionar etiquetas de Git y el CHANGELOG automáticamente.\n  - **CI/CD Robusto**: GitHub Actions ejecuta tests unitarios (PHPUnit), análisis estático (PHPStan nivel 7) y auditorías de seguridad en cada commit.\n  - **Mirroring Staging**: Existe una rama `staging` que se despliega automáticamente para validación interna antes de pasar a `main`."
    },
    {
        "id": "section-9",
        "title": "2.7 Seguridad (v1.3.2 - HMAC & Mobile Key)",
        "text": "**Estado actual (académico)**: controles de hardening activos (CSP con nonce en `script-src`, CSRF, rate limit, sesión) con tests automatizados y guía de verificación.\n\n- **HMAC Interno**: Las comunicaciones entre la App y los microservicios están firmadas con HMAC usando una `INTERNAL_API_KEY`.\n- **X-Mobile-Key**: Se ha añadido una cabecera de seguridad obligatoria (`X-Mobile-Key`) para endpoints sensibles, permitiendo el acceso controlado desde aplicaciones externas o móviles sin comprometer la sesión web.\n\n\n#### Content Security Policy (CSP) con Nonces Dinámicos\n\n- **Implementación**: CSP estricta eliminando `'unsafe-inline'` de `script-src`.\n- **Nonces criptográficos**: 128 bits de entropía, únicos por request.\n- **Generador**: `src/Security/Http/CspNonceGenerator.php` usa `random_bytes(16)` + base64.\n- **Integración**:\n  - `src/bootstrap.php`: genera nonce, lo guarda en `$_SERVER['CSP_NONCE']` y lo pasa a `SecurityHeaders::apply($nonce)`.\n  - `public/index.php`: mismo flujo para la página de intro.\n  - Vistas (`views/layouts/header.php`, `public/index.php`): scripts tienen atributo `nonce=\"...\"`.\n\n#### Headers CSP Actuales\n\n```\nscript-src 'self' 'nonce-XXXXX...' https://cdn.tailwindcss.com https://cdn.jsdelivr.net\nstyle-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdn.tailwindcss.com\n```\n\n**Nota**: `style-src` mantiene `'unsafe-inline'` por requisito de Tailwind CDN (inyecta estilos dinámicamente). Esto NO compromete la protección XSS, que es el objetivo principal de CSP.\n\n#### Otras Medidas de Seguridad\n\n- **CSRF Protection**: Tokens únicos por sesión, validados en `CsrfMiddleware`.\n- **Rate Limiting**: 100 requests/minuto por IP+ruta (`RateLimiter`, `RateLimitMiddleware`).\n- **Session Security**: \n  - Validación de IP y User-Agent (`SessionIntegrity`).\n  - TTL de sesión (`SessionTtl`).\n  - Detección de replay attacks (`SessionReplayMonitor`).\n- **Input Sanitization**: `Sanitizer` elimina tags peligrosos (`<script>`, `onerror`, etc.).\n- **Security Headers**: HSTS, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, etc.\n- **HMAC**: Autenticación de microservicios con `HmacService`.\n\n#### Testing de Seguridad\n\n- Tests de CSP/CSRF/rate limit/sesión/sanitización en `tests/Security/`\n- Verificación manual guiada en `docs/security/security_verification.md`\n\n#### Documentación de Seguridad\n\n- `docs/security/security.md`: medidas completas de seguridad\n- `docs/security/security_verification.md`: guía de verificación con 10 pruebas prácticas\n- `docs/security/README.md`: índice y quick start\n\n#### Verificación Rápida\n\n```bash\n# Ver headers CSP\ncurl -I http://localhost:8080/ | grep -i content-security-policy\n\n# Verificar nonces únicos (ejecutar 3 veces)\ncurl -I http://localhost:8080/ 2>&1 | grep -o \"nonce-[^']*\"\n\n# Tests de seguridad\nvendor/bin/phpunit tests/Security/ --testdox\n```\n\n---"
    },
    {
        "id": "section-10",
        "title": "3. Calidad, CI y auditorías",
        "text": "- **Pruebas**:\n  - App principal: `vendor/bin/phpunit` (suite completa; ver salida de PHPUnit)\n  - Microservicios: `rag-service/phpunit.xml`, `openai-service/phpunit.xml`\n\n- **PHPStan**: `vendor/bin/phpstan analyse --memory-limit=1G` (config en `phpstan.neon`, nivel 7, excluye `src/Dev`; bloque `ignoreErrors` comentado).\n\n- **QA frontend**: Playwright (`playwright.config.cjs`), Pa11y (`bin/pa11y-all.sh`), Lighthouse (`lighthouserc.json`), SonarCloud (ver ADR-003).\n\n- **CI/CD (GitHub Actions)**: jobs de PHPUnit, PHPStan, Pa11y, Lighthouse, Playwright, SonarCloud; deploy/rollback FTP según pipelines definidos. Implementa **Semantic Release** para versionado automático (v1.3.x).\n\n- **Seguridad**: CSP con nonce en `script-src` (v1.2.0), CSRF, rate limiting, session security, y autenticación por cabecera `X-Mobile-Key` (v1.3.0).\n\n\n- **RAG Scalability (Enterprise)**: La arquitectura está diseñada para evolucionar de un \"RAG Ligero\" (JSON) a un \"RAG Enterprise\" (Base de Datos Vectorial). Esto permitiría manejar gigas o teras de información (ej. jurisprudencia en un **buffet de abogados**, miles de contratos) manteniendo latencias de milisegundos mediante índices HNSW y estrategias de chunking semántico. Incluye el uso de OCR (AWS Textract) para digitalizar expedientes físicos.\n\n---\n\nEn conjunto, PHPUnit y PHPStan permiten verificar backend; Playwright, Pa11y y Lighthouse cubren flujos de UI y auditorías de navegador; SonarCloud centraliza métricas y reportes según su configuración."
    },
    {
        "id": "section-11",
        "title": "4. Documentación y fuentes de conocimiento",
        "text": "- **Índice general**: `docs/README.md` (reorganizado v1.2.0).\n- **Arquitectura**: `docs/architecture/ARCHITECTURE.md`; ADRs en `docs/architecture/ADR-*.md`.\n- **Seguridad** (nuevo): `docs/security/` con `security.md`, `security_verification.md` y README.\n- **APIs**: `docs/api/API_REFERENCE.md` (usa endpoints reales: `/comics/generate`, `/rag/heroes`, `/v1/chat`, proxies heatmap).\n- **Microservicios**:\n  - `rag-service/README.md`, `rag-service/doc/*`.\n  - `openai-service/doc/*`.\n  - `docs/microservicioheatmap/README.md`.\n- **Gestión de proyecto**: `docs/project-management/` con CHANGELOG.md (v1.2.0), ROADMAP.md, CONTRIBUTING.md, TASKS_AUTOMATION.md.\n- **Desarrollo**: `docs/development/` con agent.md, analisis_estructura.md.\n- **Guías**: `docs/guides/getting-started.md`, `docs/guides/testing.md`, `docs/guides/authentication.md`.\n- **Otros**: `docs/architecture/USE_CASES.md`, `docs/architecture/REQUIREMENTS.md`, `docs/deployment/deploy.md`, `k8s/DEPLOY_K8S.md` (guía de despliegue en Kubernetes y manifiestos en `k8s/`).\n\n---\n\nUn desarrollador nuevo debería empezar por `docs/README.md` para el índice, leer `docs/architecture/ARCHITECTURE.md` y los ADRs para decisiones clave, luego revisar `docs/api/API_REFERENCE.md` y los README de cada microservicio. Las guías de testing y automatización explican cómo ejecutar suites y scripts."
    },
    {
        "id": "section-12",
        "title": "5. Reglas para el futuro Marvel Agent",
        "text": "1. **Fuentes permitidas**: este archivo, la documentación listada y el código real. Si hay conflicto, prevalece el código.\n2. **No inventar**: no crear endpoints ni microservicios inexistentes. Si falta información, indicarlo.\n3. **Citar**: mencionar el archivo de soporte cuando aplique (ej.: `docs/architecture/ARCHITECTURE.md`, `rag-service/README.md`).\n4. **Endpoints reales**: `/v1/chat` (openai-service), `/rag/heroes` (rag-service), proxies heatmap (`/api/heatmap/*.php`), rutas HTML según `PageController`.\n5. **Configuración**: hablar solo de variables que estén en `.env` o en código (`OPENAI_API_KEY`, `OPENAI_SERVICE_URL`, `RAG_USE_EMBEDDINGS`, `HEATMAP_API_*`, etc.).\n6. **Estado del agente**: `/agentia` es frontend con respuestas simuladas; el backend RAG/LLM se añadirá después usando esta memoria.\n7. **Infra y despliegue**: el agente puede responder dónde corren microservicios (subdominios, hosting, VM/Google Cloud) y qué está dockerizado, solo si está documentado aquí, en los docs listados o en configuración real. Si falta info, debe decir que no está documentado.\n8. **Respuestas explicativas**: debe priorizar respuestas técnicas y explicativas (no solo bullets), usando la info de infraestructura y microservicios para ubicar dónde corre cada componente.\n\n---"
    },
    {
        "id": "section-13",
        "title": "6. Ejemplos de respuestas del Marvel Agent",
        "text": "- **Pregunta:** “¿Tiene arquitectura clean?”  \n  **Respuesta ejemplo:** Sí. La app principal sigue Clean Architecture: Presentación (router/vistas) → Aplicación (casos de uso) → Dominio (entidades/contratos) → Infraestructura (repos, clientes externos). Las dependencias fluyen hacia el dominio, lo que permite cambiar microservicios o proveedores sin romper la lógica central.\n\n- **Pregunta:** “¿Dónde están desplegados los microservicios?”  \n  **Respuesta ejemplo:** En local: app en `localhost:8080`, `openai-service` en `8081`, `rag-service` en `8082`. En hosting: la app vive en el dominio principal (`APP_PUBLIC_URL`) y los microservicios PHP se exponen en subdominios (`openai-service.contenido.creawebes.com`, `rag-service.contenido.creawebes.com`). El heatmap está dockerizado en una VM accesible en `http://34.74.102.123:8080`.\n\n- **Pregunta:** “¿Qué hace el microservicio de heatmap?”  \n  **Respuesta ejemplo:** Es un servicio Python/Flask con SQLite que registra clics de la web. Exponen `/`, `/health`, `POST /track` y `GET /events`. Está dockerizado en una VM (Google Cloud) y se consume desde la app PHP mediante proxies que inyectan el token `HEATMAP_API_TOKEN`.\n\n- **Pregunta:** “¿Cuál es la diferencia entre /rag/heroes y /rag/agent?”  \n  **Respuesta ejemplo:** Ambos viven en el mismo `rag-service`. `/rag/heroes` compara dos héroes usando la KB de héroes (JSON + embeddings opcionales). `/rag/agent` responde preguntas técnicas usando la memoria maestra del proyecto (otra KB). Comparten cliente LLM (`openai-service`) y configuración, con fallback léxico si no hay embeddings.\n\n- **Pregunta:** “¿Qué automatizaciones externas usa el proyecto?”  \n  **Respuesta ejemplo:** Hay un workflow n8n (`Daily Marvel YouTube Video Fetcher and Backend Sync.json`) que consulta la API de YouTube con `GOOGLE_YT_API_KEY` y envía el último video al endpoint PHP `/api/actualizar-video-marvel.php` con autorización Bearer (`MARVEL_UPDATE_TOKEN`). Así se refrescan contenidos sin tocar el dominio."
    },
    {
        "id": "section-14",
        "title": "Fase 5 — Tests rápidos de seguridad",
        "text": "- Existe un grupo `@group security` en PHPUnit para chequear rápidamente CSRF, sanitización del RAG y rate-limit básico por IP+path.\n- Se ejecuta con: `vendor/bin/phpunit --group security` o desde VS Code con la tarea “Run Security Tests”.\n- Cobertura mínima:\n  - CSRF: tokens inválidos se rechazan.\n  - Sanitización RAG: elimina `<script>`/`onerror` de preguntas y mantiene el texto útil.\n  - Rate limit: bloquea después de superar el máximo de intentos configurado por IP+ruta.\n\n---\n\n Regla obligatoria:\nCada vez que se actualice este archivo maestro de memoria del Marvel Agent, hay que ejecutar SIEMPRE los dos comandos de regeneración desde la raíz del proyecto:\n\ncd rag-service && php bin/build_marvel_agent_kb.php\ncd rag-service && php bin/generate_agent_embeddings.php\n\n\nSolo así la KB (marvel_agent_kb.json) y los embeddings (marvel_agent_embeddings.json) quedarán alineados y el Marvel Agent usará la memoria correcta en modo vectorial.****"
    }
]